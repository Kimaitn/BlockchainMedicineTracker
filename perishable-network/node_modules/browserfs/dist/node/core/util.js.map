{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../src/core/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Grab bag of utility functions used across the code.\n */\nimport {FileSystem} from './file_system';\nimport * as path from 'path';\n\n/**\n * Checks for any IE version, including IE11 which removed MSIE from the\n * userAgent string.\n */\nexport const isIE: boolean = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\n\n/**Ã¥\n * Check if we're in a web worker.\n */\nexport const isWebWorker: boolean = typeof window === \"undefined\";\n\nexport interface Arrayish<T> {\n  [idx: number]: T;\n  length: number;\n}\n\n/**\n * Synchronous recursive makedir.\n */\nexport function mkdirpSync(p: string, mode: number, fs: FileSystem): void {\n  if (!fs.existsSync(p)) {\n    mkdirpSync(path.dirname(p), mode, fs);\n    fs.mkdirSync(p, mode);\n  }\n}\n\n/**\n * Converts a buffer into an array buffer. Attempts to do so in a\n * zero-copy manner, e.g. the array references the same memory.\n */\nexport function buffer2ArrayBuffer(buff: Buffer): ArrayBuffer {\n  const u8 = buffer2Uint8array(buff),\n    u8offset = u8.byteOffset,\n    u8Len = u8.byteLength;\n  if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\n    return u8.buffer;\n  } else {\n    return u8.buffer.slice(u8offset, u8offset + u8Len);\n  }\n}\n\n/**\n * Converts a buffer into a Uint8Array. Attempts to do so in a\n * zero-copy manner, e.g. the array references the same memory.\n */\nexport function buffer2Uint8array(buff: Buffer): Uint8Array {\n  if (buff instanceof Uint8Array) {\n    // BFS & Node v4.0 buffers *are* Uint8Arrays.\n    return <any> buff;\n  } else {\n    // Uint8Arrays can be constructed from arrayish numbers.\n    // At this point, we assume this isn't a BFS array.\n    return new Uint8Array(buff);\n  }\n}\n\n/**\n * Converts the given arrayish object into a Buffer. Attempts to\n * be zero-copy.\n */\nexport function arrayish2Buffer(arr: Arrayish<number>): Buffer {\n  if (arr instanceof Buffer) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return uint8Array2Buffer(arr);\n  } else {\n    return new Buffer(<number[]> arr);\n  }\n}\n\n/**\n * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\n */\nexport function uint8Array2Buffer(u8: Uint8Array): Buffer {\n  if (u8 instanceof Buffer) {\n    return u8;\n  } else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\n    return arrayBuffer2Buffer(u8.buffer);\n  } else {\n    return new Buffer(u8);\n  }\n}\n\n/**\n * Converts the given array buffer into a Buffer. Attempts to be\n * zero-copy.\n */\nexport function arrayBuffer2Buffer(ab: ArrayBuffer): Buffer {\n  try {\n    // Works in BFS and Node v4.2.\n    return new Buffer(<any> ab);\n  } catch (e) {\n    // I believe this copies, but there's no avoiding it in Node < v4.2\n    return new Buffer(new Uint8Array(ab));\n  }\n}\n\n/**\n * Copies a slice of the given buffer\n */\nexport function copyingSlice(buff: Buffer, start: number = 0, end = buff.length): Buffer {\n  if (start < 0 || end < 0 || end > buff.length || start > end) {\n    throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\n  }\n  if (buff.length === 0) {\n    // Avoid s0 corner case in ArrayBuffer case.\n    return new Buffer(0);\n  } else {\n    let u8 = buffer2Uint8array(buff),\n      s0 = buff[0],\n      newS0 = (s0 + 1) % 0xFF;\n\n    buff[0] = newS0;\n    if (u8[0] === newS0) {\n      // Same memory. Revert & copy.\n      u8[0] = s0;\n      return uint8Array2Buffer(u8.slice(start, end));\n    } else {\n      // Revert.\n      buff[0] = s0;\n      return uint8Array2Buffer(u8.subarray(start, end));\n    }\n  }\n}\n"]}