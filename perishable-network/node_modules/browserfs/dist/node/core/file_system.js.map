{"version":3,"file":"file_system.js","sourceRoot":"","sources":["../../../src/core/file_system.ts"],"names":[],"mappings":"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","sourcesContent":["import {ApiError, ErrorCode} from './api_error';\nimport Stats from './node_fs_stats';\nimport {File, BaseFile} from './file';\nimport {FileFlag, ActionType} from './file_flag';\nimport * as path from 'path';\n\n/**\n * Interface for a filesystem. **All** BrowserFS FileSystems should implement\n * this interface.\n *\n * Below, we denote each API method as **Core**, **Supplemental**, or\n * **Optional**.\n *\n * ### Core Methods\n *\n * **Core** API methods *need* to be implemented for basic read/write\n * functionality.\n *\n * Note that read-only FileSystems can choose to not implement core methods\n * that mutate files or metadata. The default implementation will pass a\n * NOT_SUPPORTED error to the callback.\n *\n * ### Supplemental Methods\n *\n * **Supplemental** API methods do not need to be implemented by a filesystem.\n * The default implementation implements all of the supplemental API methods in\n * terms of the **core** API methods.\n *\n * Note that a file system may choose to implement supplemental methods for\n * efficiency reasons.\n *\n * The code for some supplemental methods was adapted directly from NodeJS's\n * fs.js source code.\n *\n * ### Optional Methods\n *\n * **Optional** API methods provide functionality that may not be available in\n * all filesystems. For example, all symlink/hardlink-related API methods fall\n * under this category.\n *\n * The default implementation will pass a NOT_SUPPORTED error to the callback.\n *\n * ### Argument Assumptions\n *\n * You can assume the following about arguments passed to each API method:\n *\n * * **Every path is an absolute path.** Meaning, `.`, `..`, and other items\n *   are resolved into an absolute form.\n * * **All arguments are present.** Any optional arguments at the Node API level\n *   have been passed in with their default values.\n * * **The callback will reset the stack depth.** When your filesystem calls the\n *   callback with the requested information, it will use `setImmediate` to\n *   reset the JavaScript stack depth before calling the user-supplied callback.\n * @class FileSystem\n */\nexport interface FileSystem {\n  /**\n   * **Optional**: Returns the name of the file system.\n   * @method FileSystem#getName\n   * @return {string}\n   */\n  getName(): string;\n  /**\n   * **Optional**: Passes the following information to the callback:\n   *\n   * * Total number of bytes available on this file system.\n   * * number of free bytes available on this file system.\n   *\n   * @method FileSystem#diskSpace\n   * @todo This info is not available through the Node API. Perhaps we could do a\n   *   polyfill of diskspace.js, or add a new Node API function.\n   * @param {string} path The path to the location that is being queried. Only\n   *   useful for filesystems that support mount points.\n   * @param {FileSystem~diskSpaceCallback} cb\n   */\n  diskSpace(p: string, cb: (total: number, free: number) => any): void;\n  /**\n   * **Core**: Is this filesystem read-only?\n   * @method FileSystem#isReadOnly\n   * @return {boolean} True if this FileSystem is inherently read-only.\n   */\n  isReadOnly(): boolean;\n  /**\n   * **Core**: Does the filesystem support optional symlink/hardlink-related\n   *   commands?\n   * @method FileSystem#supportsLinks\n   * @return {boolean} True if the FileSystem supports the optional\n   *   symlink/hardlink-related commands.\n   */\n  supportsLinks(): boolean;\n  /**\n   * **Core**: Does the filesystem support optional property-related commands?\n   * @method FileSystem#supportsProps\n   * @return {boolean} True if the FileSystem supports the optional\n   *   property-related commands (permissions, utimes, etc).\n   */\n  supportsProps(): boolean;\n  /**\n   * **Core**: Does the filesystem support the optional synchronous interface?\n   * @method FileSystem#supportsSynch\n   * @return {boolean} True if the FileSystem supports synchronous operations.\n   */\n  supportsSynch(): boolean;\n  // **CORE API METHODS**\n  // File or directory operations\n  /**\n   * **Core**: Asynchronous rename. No arguments other than a possible exception\n   * are given to the completion callback.\n   * @method FileSystem#rename\n   * @param {string} oldPath\n   * @param {string} newPath\n   * @param {FileSystem~nodeCallback} cb\n   */\n  rename(oldPath: string, newPath: string, cb: (err?: ApiError) => void): void;\n  /**\n   * **Core**: Synchronous rename.\n   * @method FileSystem#renameSync\n   * @param {string} oldPath\n   * @param {string} newPath\n   */\n  renameSync(oldPath: string, newPath: string): void;\n  /**\n   * **Core**: Asynchronous `stat` or `lstat`.\n   * @method FileSystem#stat\n   * @param {string} path\n   * @param {boolean} isLstat True if this is `lstat`, false if this is regular\n   *   `stat`.\n   * @param {FileSystem~nodeStatsCallback} cb\n   */\n  stat(p: string, isLstat: boolean, cb: (err: ApiError, stat?: Stats) => void): void;\n  /**\n   * **Core**: Synchronous `stat` or `lstat`.\n   * @method FileSystem#statSync\n   * @param {string} path\n   * @param {boolean} isLstat True if this is `lstat`, false if this is regular\n   *   `stat`.\n   * @return {BrowserFS.node.fs.Stats}\n   */\n  statSync(p: string, isLstat: boolean): Stats;\n  // File operations\n  /**\n   * **Core**: Asynchronous file open.\n   * @see http://www.manpagez.com/man/2/open/\n   * @method FileSystem#open\n   * @param {string} path\n   * @param {BrowserFS.FileMode} flags Handles the complexity of the various file\n   *   modes. See its API for more details.\n   * @param {number} mode Mode to use to open the file. Can be ignored if the\n   *   filesystem doesn't support permissions.\n   * @param {FileSystem~fileCallback} cb\n   */\n  open(p: string, flag: FileFlag, mode: number, cb: (err: ApiError, fd?: File) => any): void;\n  /**\n   * **Core**: Synchronous file open.\n   * @see http://www.manpagez.com/man/2/open/\n   * @method FileSystem#openSync\n   * @param {string} path\n   * @param {BrowserFS.FileMode} flags Handles the complexity of the various file\n   *   modes. See its API for more details.\n   * @param {number} mode Mode to use to open the file. Can be ignored if the\n   *   filesystem doesn't support permissions.\n   * @return {BrowserFS.File}\n   */\n  openSync(p: string, flag: FileFlag, mode: number): File;\n  /**\n   * **Core**: Asynchronous `unlink`.\n   * @method FileSystem#unlink\n   * @param [string] path\n   * @param [FileSystem~nodeCallback] cb\n   */\n  unlink(p: string, cb: (e?: ApiError) => void): void;\n  /**\n   * **Core**: Synchronous `unlink`.\n   * @method FileSystem#unlinkSync\n   * @param {string} path\n   */\n  unlinkSync(p: string): void;\n  // Directory operations\n  /**\n   * **Core**: Asynchronous `rmdir`.\n   * @method FileSystem#rmdir\n   * @param {string} path\n   * @param {FileSystem~nodeCallback} cb\n   */\n  rmdir(p: string, cb: (e?: ApiError) => void): void;\n  /**\n   * **Core**: Synchronous `rmdir`.\n   * @method FileSystem#rmdirSync\n   * @param {string} path\n   */\n  rmdirSync(p: string): void;\n  /**\n   * **Core**: Asynchronous `mkdir`.\n   * @method FileSystem#mkdir\n   * @param {string} path\n   * @param {number?} mode Mode to make the directory using. Can be ignored if\n   *   the filesystem doesn't support permissions.\n   * @param {FileSystem~nodeCallback} cb\n   */\n  mkdir(p: string, mode: number, cb: (e?: ApiError) => void): void;\n  /**\n   * **Core**: Synchronous `mkdir`.\n   * @method FileSystem#mkdirSync\n   * @param {string} path\n   * @param {number} mode Mode to make the directory using. Can be ignored if\n   *   the filesystem doesn't support permissions.\n   */\n  mkdirSync(p: string, mode: number): void;\n  /**\n   * **Core**: Asynchronous `readdir`. Reads the contents of a directory.\n   *\n   * The callback gets two arguments `(err, files)` where `files` is an array of\n   * the names of the files in the directory excluding `'.'` and `'..'`.\n   * @method FileSystem#readdir\n   * @param {string} path\n   * @param {FileSystem~readdirCallback} cb\n   */\n  readdir(p: string, cb: (err: ApiError, files?: string[]) => void): void;\n  /**\n   * **Core**: Synchronous `readdir`. Reads the contents of a directory.\n   * @method FileSystem#readdirSync\n   * @param {string} path\n   * @return {string[]}\n   */\n  readdirSync(p: string): string[];\n  // **SUPPLEMENTAL INTERFACE METHODS**\n  // File or directory operations\n  /**\n   * **Supplemental**: Test whether or not the given path exists by checking with\n   * the file system. Then call the callback argument with either true or false.\n   * @method FileSystem#exists\n   * @param {string} path\n   * @param {FileSystem~existsCallback} cb\n   */\n  exists(p: string, cb: (exists: boolean) => void): void;\n  /**\n   * **Supplemental**: Test whether or not the given path exists by checking with\n   * the file system.\n   * @method FileSystem#existsSync\n   * @param {string} path\n   * @return {boolean}\n   */\n  existsSync(p: string): boolean;\n  /**\n   * **Supplemental**: Asynchronous `realpath`. The callback gets two arguments\n   * `(err, resolvedPath)`.\n   *\n   * Note that the Node API will resolve `path` to an absolute path.\n   * @method FileSystem#realpath\n   * @param {string} path\n   * @param {Object} cache An object literal of mapped paths that can be used to\n   *   force a specific path resolution or avoid additional `fs.stat` calls for\n   *   known real paths. If not supplied by the user, it'll be an empty object.\n   * @param {FileSystem~pathCallback} cb\n   */\n  realpath(p: string, cache: {[path: string]: string}, cb: (err: ApiError, resolvedPath?: string) => any): void;\n  /**\n   * **Supplemental**: Synchronous `realpath`.\n   *\n   * Note that the Node API will resolve `path` to an absolute path.\n   * @method FileSystem#realpathSync\n   * @param {string} path\n   * @param {Object} cache An object literal of mapped paths that can be used to\n   *   force a specific path resolution or avoid additional `fs.stat` calls for\n   *   known real paths. If not supplied by the user, it'll be an empty object.\n   * @return {string}\n   */\n  realpathSync(p: string, cache: {[path: string]: string}): string;\n  // File operations\n  /**\n   *\n   * **Supplemental**: Asynchronous `truncate`.\n   * @method FileSystem#truncate\n   * @param {string} path\n   * @param {number} len\n   * @param {FileSystem~nodeCallback} cb\n   */\n  truncate(p: string, len: number, cb: (e?: ApiError) => void): void;\n  /**\n   * **Supplemental**: Synchronous `truncate`.\n   * @method FileSystem#truncateSync\n   * @param {string} path\n   * @param {number} len\n   */\n  truncateSync(p: string, len: number): void;\n  /**\n   * **Supplemental**: Asynchronously reads the entire contents of a file.\n   * @method FileSystem#readFile\n   * @param {string} filename\n   * @param {string} encoding If non-null, the file's contents should be decoded\n   *   into a string using that encoding. Otherwise, if encoding is null, fetch\n   *   the file's contents as a Buffer.\n   * @param {BrowserFS.FileMode} flag\n   * @param {FileSystem~readCallback} cb If no encoding is specified, then the\n   *   raw buffer is returned.\n   */\n  readFile(fname: string, encoding: string | null, flag: FileFlag, cb: (err: ApiError, data?: any) => void): void;\n  /**\n   * **Supplemental**: Synchronously reads the entire contents of a file.\n   * @method FileSystem#readFileSync\n   * @param {string} filename\n   * @param {string} encoding If non-null, the file's contents should be decoded\n   *   into a string using that encoding. Otherwise, if encoding is null, fetch\n   *   the file's contents as a Buffer.\n   * @param {BrowserFS.FileMode} flag\n   * @return {(string|BrowserFS.Buffer)}\n   */\n  readFileSync(fname: string, encoding: string, flag: FileFlag): any;\n  /**\n   * **Supplemental**: Asynchronously writes data to a file, replacing the file\n   * if it already exists.\n   *\n   * The encoding option is ignored if data is a buffer.\n   * @method FileSystem#writeFile\n   * @param {string} filename\n   * @param {(string | BrowserFS.node.Buffer)} data\n   * @param {string} encoding\n   * @param {BrowserFS.FileMode} flag\n   * @param {number} mode\n   * @param {FileSystem~nodeCallback} cb\n   */\n  writeFile(fname: string, data: any, encoding: string, flag: FileFlag, mode: number, cb: (err: ApiError) => void): void;\n  /**\n   * **Supplemental**: Synchronously writes data to a file, replacing the file\n   * if it already exists.\n   *\n   * The encoding option is ignored if data is a buffer.\n   * @method FileSystem#writeFileSync\n   * @param {string} filename\n   * @param {(string | BrowserFS.node.Buffer)} data\n   * @param {string} encoding\n   * @param {BrowserFS.FileMode} flag\n   * @param {number} mode\n   */\n  writeFileSync(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number): void;\n  /**\n   * **Supplemental**: Asynchronously append data to a file, creating the file if\n   * it not yet exists.\n   * @method FileSystem#appendFile\n   * @param {string} filename\n   * @param {(string | BrowserFS.node.Buffer)} data\n   * @param {string} encoding\n   * @param {BrowserFS.FileMode} flag\n   * @param {number} mode\n   * @param {FileSystem~nodeCallback} cb\n   */\n  appendFile(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number, cb: (err: ApiError) => void): void;\n  /**\n   * **Supplemental**: Synchronously append data to a file, creating the file if\n   * it not yet exists.\n   * @method FileSystem#appendFileSync\n   * @param {string} filename\n   * @param {(string | BrowserFS.node.Buffer)} data\n   * @param {string} encoding\n   * @param {BrowserFS.FileMode} flag\n   * @param {number} mode\n   */\n  appendFileSync(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number): void;\n  // **OPTIONAL INTERFACE METHODS**\n  // Property operations\n  // This isn't always possible on some filesystem types (e.g. Dropbox).\n  /**\n   * **Optional**: Asynchronous `chmod` or `lchmod`.\n   * @method FileSystem#chmod\n   * @param {string} path\n   * @param {boolean} isLchmod `True` if `lchmod`, false if `chmod`. Has no\n   *   bearing on result if links aren't supported.\n   * @param {number} mode\n   * @param {FileSystem~nodeCallback} cb\n   */\n  chmod(p: string, isLchmod: boolean, mode: number, cb: (e?: ApiError) => void): void;\n  /**\n   * **Optional**: Synchronous `chmod` or `lchmod`.\n   * @method FileSystem#chmodSync\n   * @param {string} path\n   * @param {boolean} isLchmod `True` if `lchmod`, false if `chmod`. Has no\n   *   bearing on result if links aren't supported.\n   * @param {number} mode\n   */\n  chmodSync(p: string, isLchmod: boolean, mode: number): void;\n  /**\n   * **Optional**: Asynchronous `chown` or `lchown`.\n   * @method FileSystem#chown\n   * @param {string} path\n   * @param {boolean} isLchown `True` if `lchown`, false if `chown`. Has no\n   *   bearing on result if links aren't supported.\n   * @param {number} uid\n   * @param {number} gid\n   * @param {FileSystem~nodeCallback} cb\n   */\n  chown(p: string, isLchown: boolean, uid: number, gid: number, cb: (e?: ApiError) => void): void;\n  /**\n   * **Optional**: Synchronous `chown` or `lchown`.\n   * @method FileSystem#chownSync\n   * @param {string} path\n   * @param {boolean} isLchown `True` if `lchown`, false if `chown`. Has no\n   *   bearing on result if links aren't supported.\n   * @param {number} uid\n   * @param {number} gid\n   */\n  chownSync(p: string, isLchown: boolean, uid: number, gid: number): void;\n  /**\n   * **Optional**: Change file timestamps of the file referenced by the supplied\n   * path.\n   * @method FileSystem#utimes\n   * @param {string} path\n   * @param {Date} atime\n   * @param {Date} mtime\n   * @param {FileSystem~nodeCallback} cb\n   */\n  utimes(p: string, atime: Date, mtime: Date, cb: (e?: ApiError) => void): void;\n  /**\n   * **Optional**: Change file timestamps of the file referenced by the supplied\n   * path.\n   * @method FileSystem#utimesSync\n   * @param {string} path\n   * @param {Date} atime\n   * @param {Date} mtime\n   */\n  utimesSync(p: string, atime: Date, mtime: Date): void;\n  // Symlink operations\n  // Symlinks aren't always supported.\n  /**\n   * **Optional**: Asynchronous `link`.\n   * @method FileSystem#link\n   * @param {string} srcpath\n   * @param {string} dstpath\n   * @param {FileSystem~nodeCallback} cb\n   */\n  link(srcpath: string, dstpath: string, cb: (e?: ApiError) => void): void;\n  /**\n   * **Optional**: Synchronous `link`.\n   * @method FileSystem#linkSync\n   * @param {string} srcpath\n   * @param {string} dstpath\n   */\n  linkSync(srcpath: string, dstpath: string): void;\n  /**\n   * **Optional**: Asynchronous `symlink`.\n   * @method FileSystem#symlink\n   * @param {string} srcpath\n   * @param {string} dstpath\n   * @param {string} type can be either `'dir'` or `'file'`\n   * @param {FileSystem~nodeCallback} cb\n   */\n  symlink(srcpath: string, dstpath: string, type: string, cb: (e?: ApiError) => void): void;\n  /**\n   * **Optional**: Synchronous `symlink`.\n   * @method FileSystem#symlinkSync\n   * @param {string} srcpath\n   * @param {string} dstpath\n   * @param {string} type can be either `'dir'` or `'file'`\n   */\n  symlinkSync(srcpath: string, dstpath: string, type: string): void;\n  /**\n   * **Optional**: Asynchronous readlink.\n   * @method FileSystem#readlink\n   * @param {string} path\n   * @param {FileSystem~pathCallback} callback\n   */\n  readlink(p: string, cb: (e: ApiError, p?: string) => void): void;\n  /**\n   * **Optional**: Synchronous readlink.\n   * @method FileSystem#readlinkSync\n   * @param {string} path\n   */\n  readlinkSync(p: string): string;\n}\n\n/**\n * Contains typings for static functions on the file system constructor.\n */\nexport interface FileSystemConstructor {\n  /**\n   * **Core**: Returns 'true' if this filesystem is available in the current\n   * environment. For example, a `localStorage`-backed filesystem will return\n   * 'false' if the browser does not support that API.\n   *\n   * Defaults to 'false', as the FileSystem base class isn't usable alone.\n   * @method FileSystem.isAvailable\n   * @return {boolean}\n   */\n  isAvailable(): boolean;\n}\n\n/**\n * Basic filesystem class. Most filesystems should extend this class, as it\n * provides default implementations for a handful of methods.\n */\nexport class BaseFileSystem {\n  public supportsLinks(): boolean {\n    return false;\n  }\n  public diskSpace(p: string, cb: (total: number, free: number) => any): void {\n    cb(0, 0);\n  }\n  /**\n   * Opens the file at path p with the given flag. The file must exist.\n   * @param p The path to open.\n   * @param flag The flag to use when opening the file.\n   */\n  public openFile(p: string, flag: FileFlag, cb: (e: ApiError, file?: File) => void): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  /**\n   * Create the file at path p with the given mode. Then, open it with the given\n   * flag.\n   */\n  public createFile(p: string, flag: FileFlag, mode: number, cb: (e: ApiError, file?: File) => void): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public open(p: string, flag: FileFlag, mode: number, cb: (err: ApiError, fd?: BaseFile) => any): void {\n    let mustBeFile = (e: ApiError, stats?: Stats): void => {\n      if (e) {\n        // File does not exist.\n        switch (flag.pathNotExistsAction()) {\n          case ActionType.CREATE_FILE:\n            // Ensure parent exists.\n            return this.stat(path.dirname(p), false, (e: ApiError, parentStats?: Stats) => {\n              if (e) {\n                cb(e);\n              } else if (!parentStats.isDirectory()) {\n                cb(ApiError.ENOTDIR(path.dirname(p)));\n              } else {\n                this.createFile(p, flag, mode, cb);\n              }\n            });\n          case ActionType.THROW_EXCEPTION:\n            return cb(ApiError.ENOENT(p));\n          default:\n            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n        }\n      } else {\n        // File exists.\n        if (stats.isDirectory()) {\n          return cb(ApiError.EISDIR(p));\n        }\n        switch (flag.pathExistsAction()) {\n          case ActionType.THROW_EXCEPTION:\n            return cb(ApiError.EEXIST(p));\n          case ActionType.TRUNCATE_FILE:\n            // NOTE: In a previous implementation, we deleted the file and\n            // re-created it. However, this created a race condition if another\n            // asynchronous request was trying to read the file, as the file\n            // would not exist for a small period of time.\n            return this.openFile(p, flag, (e: ApiError, fd?: File): void => {\n              if (e) {\n                cb(e);\n              } else {\n                fd.truncate(0, () => {\n                  fd.sync(() => {\n                    cb(null, fd);\n                  });\n                });\n              }\n            });\n          case ActionType.NOP:\n            return this.openFile(p, flag, cb);\n          default:\n            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n        }\n      }\n    };\n    this.stat(p, false, mustBeFile);\n  }\n  public rename(oldPath: string, newPath: string, cb: (err?: ApiError) => void): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public renameSync(oldPath: string, newPath: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public stat(p: string, isLstat: boolean, cb: (err: ApiError, stat?: Stats) => void): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public statSync(p: string, isLstat: boolean): Stats {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  /**\n   * Opens the file at path p with the given flag. The file must exist.\n   * @param p The path to open.\n   * @param flag The flag to use when opening the file.\n   * @return A File object corresponding to the opened file.\n   */\n  public openFileSync(p: string, flag: FileFlag, mode: number): File {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  /**\n   * Create the file at path p with the given mode. Then, open it with the given\n   * flag.\n   */\n  public createFileSync(p: string, flag: FileFlag, mode: number): File {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public openSync(p: string, flag: FileFlag, mode: number): File {\n    // Check if the path exists, and is a file.\n    let stats: Stats;\n    try {\n      stats = this.statSync(p, false);\n    } catch (e) {\n      // File does not exist.\n      switch (flag.pathNotExistsAction()) {\n        case ActionType.CREATE_FILE:\n          // Ensure parent exists.\n          let parentStats = this.statSync(path.dirname(p), false);\n          if (!parentStats.isDirectory()) {\n            throw ApiError.ENOTDIR(path.dirname(p));\n          }\n          return this.createFileSync(p, flag, mode);\n        case ActionType.THROW_EXCEPTION:\n          throw ApiError.ENOENT(p);\n        default:\n          throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n      }\n    }\n\n    // File exists.\n    if (stats.isDirectory()) {\n      throw ApiError.EISDIR(p);\n    }\n    switch (flag.pathExistsAction()) {\n      case ActionType.THROW_EXCEPTION:\n        throw ApiError.EEXIST(p);\n      case ActionType.TRUNCATE_FILE:\n        // Delete file.\n        this.unlinkSync(p);\n        // Create file. Use the same mode as the old file.\n        // Node itself modifies the ctime when this occurs, so this action\n        // will preserve that behavior if the underlying file system\n        // supports those properties.\n        return this.createFileSync(p, flag, stats.mode);\n      case ActionType.NOP:\n        return this.openFileSync(p, flag, mode);\n      default:\n        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n    }\n  }\n  public unlink(p: string, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public unlinkSync(p: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public rmdir(p: string, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public rmdirSync(p: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public mkdir(p: string, mode: number, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public mkdirSync(p: string, mode: number): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public readdir(p: string, cb: (err: ApiError, files?: string[]) => void): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public readdirSync(p: string): string[] {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public exists(p: string, cb: (exists: boolean) => void): void {\n    this.stat(p, null, function(err) {\n      cb(!err);\n    });\n  }\n  public existsSync(p: string): boolean {\n    try {\n      this.statSync(p, true);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  public realpath(p: string, cache: {[path: string]: string}, cb: (err: ApiError, resolvedPath?: string) => any): void {\n    if (this.supportsLinks()) {\n      // The path could contain symlinks. Split up the path,\n      // resolve any symlinks, return the resolved string.\n      let splitPath = p.split(path.sep);\n      // TODO: Simpler to just pass through file, find sep and such.\n      for (let i = 0; i < splitPath.length; i++) {\n        let addPaths = splitPath.slice(0, i + 1);\n        splitPath[i] = path.join.apply(null, addPaths);\n      }\n    } else {\n      // No symlinks. We just need to verify that it exists.\n      this.exists(p, function(doesExist) {\n        if (doesExist) {\n          cb(null, p);\n        } else {\n          cb(ApiError.ENOENT(p));\n        }\n      });\n    }\n  }\n  public realpathSync(p: string, cache: {[path: string]: string}): string {\n    if (this.supportsLinks()) {\n      // The path could contain symlinks. Split up the path,\n      // resolve any symlinks, return the resolved string.\n      let splitPath = p.split(path.sep);\n      // TODO: Simpler to just pass through file, find sep and such.\n      for (let i = 0; i < splitPath.length; i++) {\n        let addPaths = splitPath.slice(0, i + 1);\n        splitPath[i] = path.join.apply(path, addPaths);\n      }\n      return splitPath.join(path.sep);\n    } else {\n      // No symlinks. We just need to verify that it exists.\n      if (this.existsSync(p)) {\n        return p;\n      } else {\n        throw ApiError.ENOENT(p);\n      }\n    }\n  }\n  public truncate(p: string, len: number, cb: Function): void {\n    this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function(er: ApiError, fd?: File) {\n      if (er) {\n        return cb(er);\n      }\n      fd.truncate(len, (function(er: any) {\n        fd.close((function(er2: any) {\n          cb(er || er2);\n        }));\n      }));\n    }));\n  }\n  public truncateSync(p: string, len: number): void {\n    let fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\n    // Need to safely close FD, regardless of whether or not truncate succeeds.\n    try {\n      fd.truncateSync(len);\n    } catch (e) {\n      throw e;\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public readFile(fname: string, encoding: string, flag: FileFlag, cb: (err: ApiError, data?: any) => void): void {\n    // Wrap cb in file closing code.\n    let oldCb = cb;\n    // Get file.\n    this.open(fname, flag, 0x1a4, function(err: ApiError, fd?: File) {\n      if (err) {\n        return cb(err);\n      }\n      cb = function(err: ApiError, arg?: File) {\n        fd.close(function(err2: any) {\n          if (!err) {\n            err = err2;\n          }\n          return oldCb(err, arg);\n        });\n      };\n      fd.stat(function(err: ApiError, stat?: Stats) {\n        if (err) {\n          return cb(err);\n        }\n        // Allocate buffer.\n        let buf = new Buffer(stat.size);\n        fd.read(buf, 0, stat.size, 0, function(err) {\n          if (err) {\n            return cb(err);\n          } else if (encoding === null) {\n            return cb(err, buf);\n          }\n          try {\n            cb(null, buf.toString(encoding));\n          } catch (e) {\n            cb(e);\n          }\n        });\n      });\n    });\n  }\n  public readFileSync(fname: string, encoding: string, flag: FileFlag): any {\n    // Get file.\n    let fd = this.openSync(fname, flag, 0x1a4);\n    try {\n      let stat = fd.statSync();\n      // Allocate buffer.\n      let buf = new Buffer(stat.size);\n      fd.readSync(buf, 0, stat.size, 0);\n      fd.closeSync();\n      if (encoding === null) {\n        return buf;\n      }\n      return buf.toString(encoding);\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public writeFile(fname: string, data: any, encoding: string, flag: FileFlag, mode: number, cb: (err: ApiError) => void): void {\n    // Wrap cb in file closing code.\n    let oldCb = cb;\n    // Get file.\n    this.open(fname, flag, 0x1a4, function(err: ApiError, fd?: File) {\n      if (err) {\n        return cb(err);\n      }\n      cb = function(err: ApiError) {\n        fd.close(function(err2: any) {\n          oldCb(err ? err : err2);\n        });\n      };\n\n      try {\n        if (typeof data === 'string') {\n          data = new Buffer(data, encoding);\n        }\n      } catch (e) {\n        return cb(e);\n      }\n      // Write into file.\n      fd.write(data, 0, data.length, 0, cb);\n    });\n  }\n  public writeFileSync(fname: string, data: any, encoding: string, flag: FileFlag, mode: number): void {\n    // Get file.\n    let fd = this.openSync(fname, flag, mode);\n    try {\n      if (typeof data === 'string') {\n        data = new Buffer(data, encoding);\n      }\n      // Write into file.\n      fd.writeSync(data, 0, data.length, 0);\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public appendFile(fname: string, data: any, encoding: string, flag: FileFlag, mode: number, cb: (err: ApiError) => void): void {\n    // Wrap cb in file closing code.\n    let oldCb = cb;\n    this.open(fname, flag, mode, function(err: ApiError, fd?: File) {\n      if (err) {\n        return cb(err);\n      }\n      cb = function(err: ApiError) {\n        fd.close(function(err2: any) {\n          oldCb(err ? err : err2);\n        });\n      };\n      if (typeof data === 'string') {\n        data = new Buffer(data, encoding);\n      }\n      fd.write(data, 0, data.length, null, cb);\n    });\n  }\n  public appendFileSync(fname: string, data: any, encoding: string, flag: FileFlag, mode: number): void {\n    let fd = this.openSync(fname, flag, mode);\n    try {\n      if (typeof data === 'string') {\n        data = new Buffer(data, encoding);\n      }\n      fd.writeSync(data, 0, data.length, null);\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public chmod(p: string, isLchmod: boolean, mode: number, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public chmodSync(p: string, isLchmod: boolean, mode: number) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public chown(p: string, isLchown: boolean, uid: number, gid: number, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public chownSync(p: string, isLchown: boolean, uid: number, gid: number): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public utimes(p: string, atime: Date, mtime: Date, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public utimesSync(p: string, atime: Date, mtime: Date): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public link(srcpath: string, dstpath: string, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public linkSync(srcpath: string, dstpath: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public symlink(srcpath: string, dstpath: string, type: string, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public symlinkSync(srcpath: string, dstpath: string, type: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public readlink(p: string, cb: Function): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public readlinkSync(p: string): string {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n}\n\n/**\n * Implements the asynchronous API in terms of the synchronous API.\n * @class SynchronousFileSystem\n */\nexport class SynchronousFileSystem extends BaseFileSystem {\n  public supportsSynch(): boolean {\n    return true;\n  }\n\n  public rename(oldPath: string, newPath: string, cb: Function): void {\n    try {\n      this.renameSync(oldPath, newPath);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public stat(p: string, isLstat: boolean, cb: Function): void {\n    try {\n      cb(null, this.statSync(p, isLstat));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public open(p: string, flags: FileFlag, mode: number, cb: Function): void {\n    try {\n      cb(null, this.openSync(p, flags, mode));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public unlink(p: string, cb: Function): void {\n    try {\n      this.unlinkSync(p);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public rmdir(p: string, cb: Function): void {\n    try {\n      this.rmdirSync(p);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public mkdir(p: string, mode: number, cb: Function): void {\n    try {\n      this.mkdirSync(p, mode);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public readdir(p: string, cb: Function): void {\n    try {\n      cb(null, this.readdirSync(p));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public chmod(p: string, isLchmod: boolean, mode: number, cb: Function): void {\n    try {\n      this.chmodSync(p, isLchmod, mode);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public chown(p: string, isLchown: boolean, uid: number, gid: number, cb: Function): void {\n    try {\n      this.chownSync(p, isLchown, uid, gid);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public utimes(p: string, atime: Date, mtime: Date, cb: Function): void {\n    try {\n      this.utimesSync(p, atime, mtime);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public link(srcpath: string, dstpath: string, cb: Function): void {\n    try {\n      this.linkSync(srcpath, dstpath);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public symlink(srcpath: string, dstpath: string, type: string, cb: Function): void {\n    try {\n      this.symlinkSync(srcpath, dstpath, type);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public readlink(p: string, cb: Function): void {\n    try {\n      cb(null, this.readlinkSync(p));\n    } catch (e) {\n      cb(e);\n    }\n  }\n}\n"]}